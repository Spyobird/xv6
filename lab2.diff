diff --git a/Makefile b/Makefile
index 09d790c..35302d0 100644
--- a/Makefile
+++ b/Makefile
@@ -181,6 +181,7 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_test\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -217,7 +218,7 @@ QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
 	then echo "-gdb tcp::$(GDBPORT)"; \
 	else echo "-s -p $(GDBPORT)"; fi)
 ifndef CPUS
-CPUS := 2
+CPUS := 1
 endif
 QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
 
diff --git a/defs.h b/defs.h
index 82fb982..cb0d4a7 100644
--- a/defs.h
+++ b/defs.h
@@ -120,6 +120,7 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+int             set_prior(int);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
diff --git a/proc.c b/proc.c
index 806b1b1..4892f72 100644
--- a/proc.c
+++ b/proc.c
@@ -88,6 +88,10 @@ allocproc(void)
 found:
   p->state = EMBRYO;
   p->pid = nextpid++;
+  p->priority = 15;
+  p->t_start = 0;
+  p->t_finish = 0;
+  p->t_burst = 0;
 
   release(&ptable.lock);
 
@@ -214,6 +218,7 @@ fork(void)
 
   acquire(&ptable.lock);
 
+  np->priority = curproc->priority;
   np->state = RUNNABLE;
 
   release(&ptable.lock);
@@ -261,6 +266,11 @@ exit(void)
     }
   }
 
+  acquire(&tickslock);
+  curproc->t_finish = ticks;
+  release(&tickslock);
+  cprintf("Turnaround: %d; Waiting: %d\n", curproc->t_finish - curproc->t_start, curproc->t_finish - curproc->t_start - curproc->t_burst);
+
   // Jump into the scheduler, never to return.
   curproc->state = ZOMBIE;
   sched();
@@ -311,6 +321,30 @@ wait(void)
   }
 }
 
+int
+set_prior(int prior)
+{
+  struct proc *curproc = myproc();
+
+  acquire(&ptable.lock);
+
+  if (curproc->killed) {
+    release(&ptable.lock);
+    return -1;
+  }
+
+  if(prior > 31) {
+    prior = 31;
+  }
+  if(prior < 0) {
+    prior = 0;
+  }
+
+  curproc->priority = prior;
+  release(&ptable.lock);
+  return prior;
+}
+
 //PAGEBREAK: 42
 // Per-CPU process scheduler.
 // Each CPU calls scheduler() after setting itself up.
@@ -322,7 +356,7 @@ wait(void)
 void
 scheduler(void)
 {
-  struct proc *p;
+  struct proc *p, *q, *choice;
   struct cpu *c = mycpu();
   c->proc = 0;
   
@@ -336,6 +370,29 @@ scheduler(void)
       if(p->state != RUNNABLE)
         continue;
       
+      choice = p;
+
+      for(q = ptable.proc; q < &ptable.proc[NPROC]; q++){
+        if(q->state == RUNNABLE && q->priority < choice->priority){
+          choice = q;
+        }
+      }
+
+      for(q = ptable.proc; q < &ptable.proc[NPROC]; q++){
+        if(q != choice){
+          if(--q->priority < 0)
+            q->priority = 0;
+        }
+      }
+      
+      p = choice;
+
+      if (p->t_start == 0){
+        acquire(&tickslock);
+        p->t_start = ticks;
+        release(&tickslock);
+      }
+
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
@@ -343,6 +400,9 @@ scheduler(void)
       switchuvm(p);
       p->state = RUNNING;
 
+      if(++p->priority > 31)
+        p->priority = 31;
+
       swtch(&(c->scheduler), p->context);
       switchkvm();
 
diff --git a/proc.h b/proc.h
index 1647114..8bf2eb6 100644
--- a/proc.h
+++ b/proc.h
@@ -49,6 +49,10 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int priority;                // Priority [0, 31]
+  uint t_start;                // Start time of process
+  uint t_finish;               // End time of process
+  uint t_burst;                // Burst time of process
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/syscall.c b/syscall.c
index ee85261..9fd3b3f 100644
--- a/syscall.c
+++ b/syscall.c
@@ -103,6 +103,7 @@ extern int sys_unlink(void);
 extern int sys_wait(void);
 extern int sys_write(void);
 extern int sys_uptime(void);
+extern int sys_set_prior(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -126,6 +127,7 @@ static int (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_set_prior] sys_set_prior,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index bc5f356..d12e583 100644
--- a/syscall.h
+++ b/syscall.h
@@ -20,3 +20,4 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_set_prior 22
diff --git a/sysproc.c b/sysproc.c
index 0686d29..9143a60 100644
--- a/sysproc.c
+++ b/sysproc.c
@@ -89,3 +89,13 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+int
+sys_set_prior(void)
+{
+  int prior;
+
+  if(argint(0, &prior) < 0)
+    return -1;
+  return set_prior(prior);
+}
diff --git a/trap.c b/trap.c
index 41c66eb..602de9b 100644
--- a/trap.c
+++ b/trap.c
@@ -51,6 +51,8 @@ trap(struct trapframe *tf)
     if(cpuid() == 0){
       acquire(&tickslock);
       ticks++;
+      if (myproc() != 0 && myproc()->state == RUNNING)
+        myproc()->t_burst++;
       wakeup(&ticks);
       release(&tickslock);
     }
diff --git a/user.h b/user.h
index 4f99c52..859fa66 100644
--- a/user.h
+++ b/user.h
@@ -23,6 +23,7 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int set_prior(int);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/usys.S b/usys.S
index 8bfd8a1..7c1fbc9 100644
--- a/usys.S
+++ b/usys.S
@@ -29,3 +29,4 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(set_prior)
